package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/BurntSushi/toml"
)

// AppConfig represents the application configuration
type AppConfig struct {
	WorkItems  WorkItemsConfig            `toml:"workitems"`
	Extensions map[string]ExtensionConfig `toml:"extensions"`
}

// WorkItemsConfig represents the configuration for work items
type WorkItemsConfig struct {
	Extensions []string `toml:"extensions"`
}

// ExtensionConfig represents the configuration for an extension
type ExtensionConfig struct {
	Name               string   `toml:"name"`
	Description        string   `toml:"description"`
	TemplatesDirectory string   `toml:"templates_directory"`
	AppliesTo          []string `toml:"applies_to"`
}

// EntryPoint returns the function corresponding to the extension ID
func (e ExtensionConfig) EntryPoint(id string) interface{} {
	// Convert from snake_case to CamelCase
	parts := strings.Split(strings.Replace(id, ".", "_", -1), "_")
	var camelCase string
	for _, part := range parts {
		if len(part) > 0 {
			camelCase += strings.ToUpper(part[:1]) + part[1:]
		}
	}

	// Map of available extension functions
	extensionFuncs := map[string]interface{}{
		"ExportToTemplate": ExportToTemplate,
		"OpenInBrowser":    OpenInBrowser,
		// Add other extension functions here as they're created
	}

	if fn, exists := extensionFuncs[camelCase]; exists {
		return fn
	}
	return nil
}

// LoadConfig loads the configuration from the specified file path
func LoadConfig(configPath string) (*AppConfig, error) {
	config := &AppConfig{}

	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		return config, fmt.Errorf("config file not found: %s", configPath)
	}

	if _, err := toml.DecodeFile(configPath, config); err != nil {
		return nil, fmt.Errorf("error decoding config file: %v", err)
	}

	return config, nil
}

// GetDefaultConfigPath returns the default path for the config file
func GetDefaultConfigPath() string {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		log.Printf("Error getting user home directory: %v", err)
		return "lazyaz.toml"
	}

	return filepath.Join(homeDir, ".config", "lazyaz", "lazyaz.toml")
}

// AutoGenerateConfig creates a default configuration file if it doesn't exist
func AutoGenerateConfig(configPath string) error {
	// Check if config file already exists
	if _, err := os.Stat(configPath); err == nil {
		return nil // Config file already exists
	}

	// Create the config directory if it doesn't exist
	configDir := filepath.Dir(configPath)
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("error creating config directory: %v", err)
	}

	// Default configuration content
	defaultConfig := `autogenerated = 1

[extensions.export_to_template]
name = "Export to Template"
description = "Export a workitem to a template"
applies_to = ["workitems", "pullrequests", "pipelines"]

[extensions.open_in_browser]
name = "Open in Browser"
description = "Open in browser"
applies_to = ["workitems", "pullrequests", "pipelines"]
`

	// Write the default configuration to file
	if err := os.WriteFile(configPath, []byte(defaultConfig), 0644); err != nil {
		return fmt.Errorf("error writing default config file: %v", err)
	}

	return nil
}

// FindConfig looks for the config file in the current directory and home directory
func FindConfig() (*AppConfig, string, error) {
	// First, try the current directory
	currentDirConfig := "lazyaz.toml"
	if _, err := os.Stat(currentDirConfig); err == nil {
		config, err := LoadConfig(currentDirConfig)
		return config, currentDirConfig, err
	}

	// Then try the new config location in .config/lazyaz
	newConfig := GetDefaultConfigPath()

	// Try to auto-generate config if it doesn't exist
	if err := AutoGenerateConfig(newConfig); err == nil {
		config, err := LoadConfig(newConfig)
		return config, newConfig, err
	}

	// Finally, try the old location in home directory as fallback
	homeDir, err := os.UserHomeDir()
	if err == nil {
		oldConfig := filepath.Join(homeDir, ".lazyaz.toml")
		if _, err := os.Stat(oldConfig); err == nil {
			config, err := LoadConfig(oldConfig)
			return config, oldConfig, err
		}
	}

	// Return empty config if no config file found
	return &AppConfig{}, "", fmt.Errorf("no config file found")
}
